// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  //output = "../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  //directUrl = env("DIRECT_URL")
}

model Vendor {
  id             String        @id @default(cuid())
  name           String
  description    String?
  ownerId        String        @unique // Prisma User ID vlasnika
  owner          User          @relation("VendorOwner", fields: [ownerId], references: [id])
  address        String?
  phoneNumber    String?
  operatingHours Json?
  services       Service[]
  appointments   Appointment[]
  workers        Worker[]
  status         VendorStatus  @default(ACTIVE)
  chatSessions   ChatSession[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([ownerId])
}

enum VendorStatus {
  PENDING_APPROVAL
  ACTIVE
  SUSPENDED
  REJECTED
}

model User {
  id              String        @id @default(cuid())
  clerkId         String        @unique // From Clerk authentication
  email           String        @unique
  phoneNumber     String?       @unique 
  firstName       String?
  lastName        String?
  profileImageUrl String?
  role            UserRole      @default(USER)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  appointments    Appointment[]
  ownedVendor     Vendor?       @relation("VendorOwner")
  workerProfile   Worker?
  chatSessions    ChatSession[]
  messagesSent    ChatMessage[]

  @@index([clerkId])
}

enum UserRole {
  USER
  VENDOR_OWNER
  WORKER 
  SUPER_ADMIN
}

model Service {
  id             String        @id @default(cuid())
  name           String
  description    String?
  price          Float
  duration       Int 
  active         Boolean       @default(true) // NOVO: Dodato polje za status aktivnosti usluge
  vendorId       String 
  vendor        Vendor        @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  appointments   Appointment[]
  workers        Worker[]      @relation("WorkerServices")  // Workers who can perform this service
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([vendorId])
}

model Appointment {
  id          String            @id @default(cuid())
  userId      String            // Clerk ID of the user who booked
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceId   String
  service     Service           @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  vendorId    String 
  vendor      Vendor            @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  workerId    String?
  worker      Worker?           @relation(fields: [workerId], references: [id], onDelete: SetNull)
  startTime   DateTime
  endTime     DateTime
  status      AppointmentStatus @default(PENDING)
  notes       String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([userId])
  @@index([serviceId])
  @@index([vendorId])
  @@index([workerId])
  @@index([startTime])
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED_BY_USER
  CANCELLED_BY_VENDOR
  REJECTED
  COMPLETED
  NO_SHOW
}

model Worker {
  id            String    @id @default(cuid())
  vendorId      String
  vendor        Vendor    @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  userId        String?   @unique // Clerk User ID, if linked
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  name          String
  email         String?   @unique // Optional, could be different from User's email or for non-user workers
  phoneNumber   String?
  bio           String?
  photoUrl      String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  appointments  Appointment[]
  services      Service[]     @relation("WorkerServices") 
  availabilities WorkerAvailability[]
  scheduleOverrides WorkerScheduleOverride[]

  @@index([vendorId])
  @@index([userId])
  @@unique([vendorId, userId], name: "unique_vendor_user_worker")
}


model WorkerAvailability {
  id          String    @id @default(cuid())
  workerId    String
  worker      Worker    @relation(fields: [workerId], references: [id], onDelete: Cascade)
  dayOfWeek   Int       // 0 (Sunday) to 6 (Saturday)
  startTime   String    // "HH:mm" format, e.g., "09:00"
  endTime     String    // "HH:mm" format, e.g., "17:00"
  isAvailable Boolean   @default(true)

  @@unique([workerId, dayOfWeek]) // Each worker has one entry per day of the week
  @@index([workerId])
}

model WorkerScheduleOverride {
  id          String    @id @default(cuid())
  workerId    String
  worker      Worker    @relation(fields: [workerId], references: [id], onDelete: Cascade)
  date        DateTime  @db.Date // Specific date for the override
  startTime   String?   // "HH:mm", null if day off
  endTime     String?   // "HH:mm", null if day off
  isDayOff    Boolean   @default(false)
  notes       String?   // Reason for override

  @@unique([workerId, date])
  @@index([workerId, date])
}



model ChatSession {
  id        String     @id @default(cuid())
  userId    String     
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  adminId   String?    // Može biti Prisma User ID admina koji je poslednji odgovorio
  // admin     User?   // Ako adminId referencira User.id, može se dodati i ova relacija
  vendorId  String?    // ID salona sa kojim je sesija povezana
  vendor    Vendor?       @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  messages  ChatMessage[]

  @@index([userId])
  @@index([vendorId])
  @@index([adminId]) // Ako adminId postoji i želite da ga indeksirate
}


model ChatMessage {
  id          String      @id @default(cuid())
  sessionId   String
  session    ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  senderId    String?    // Može biti Prisma User ID ili specijalni identifikator kao "AI"                                                                                                                              // Ako senderId može biti npr. "AI", onda ova direktna relacija nije moguća na ovaj način
  senderType  SenderType 
  message    String     @db.Text
  timestamp   DateTime    @default(now())
  isRead      Boolean     @default(false)
  senderUser User?       @relation(fields: [senderId], references: [id], onDelete: SetNull, onUpdate: Cascade) 

  @@index([sessionId])
  @@index([senderId]) 
}

enum SenderType {
  USER
  ADMIN 
  AI
}